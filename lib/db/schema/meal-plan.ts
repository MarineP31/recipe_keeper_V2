import { MealType } from '@/constants/enums';

/**
 * MealPlan interface representing a planned meal
 */
export interface MealPlan {
  id: string;
  recipeId: string;
  date: string; // ISO 8601 date (YYYY-MM-DD)
  mealType: MealType;
  createdAt: string; // ISO 8601 datetime
}

/**
 * Input interface for creating a new meal plan
 */
export interface CreateMealPlanInput {
  recipeId: string;
  date: string; // ISO 8601 date
  mealType: MealType;
}

/**
 * Input interface for updating an existing meal plan
 */
export interface UpdateMealPlanInput {
  id: string;
  recipeId?: string;
  date?: string;
  mealType?: MealType;
}

/**
 * Database row interface for meal_plans table
 */
export interface MealPlanRow {
  id: string;
  recipeId: string;
  date: string;
  mealType: string;
  createdAt: string;
}

/**
 * Meal plan with recipe details (for display purposes)
 */
export interface MealPlanWithRecipe extends MealPlan {
  recipeTitle: string;
  recipeImageUri: string | null;
  recipeServings: number;
  recipePrepTime: number | null;
  recipeCookTime: number | null;
}

/**
 * Utility functions for MealPlan operations
 */
export const MealPlanUtils = {
  /**
   * Convert MealPlan to database row format
   */
  toRow(mealPlan: MealPlan): MealPlanRow {
    return {
      id: mealPlan.id,
      recipeId: mealPlan.recipeId,
      date: mealPlan.date,
      mealType: mealPlan.mealType,
      createdAt: mealPlan.createdAt,
    };
  },

  /**
   * Convert database row to MealPlan format
   */
  fromRow(row: MealPlanRow): MealPlan {
    return {
      id: row.id,
      recipeId: row.recipeId,
      date: row.date,
      mealType: row.mealType as MealType,
      createdAt: row.createdAt,
    };
  },

  /**
   * Create a new MealPlan with generated ID and timestamp
   */
  create(input: CreateMealPlanInput): MealPlan {
    const now = new Date().toISOString();
    return {
      id: '', // Will be generated by service layer
      recipeId: input.recipeId,
      date: input.date,
      mealType: input.mealType,
      createdAt: now,
    };
  },

  /**
   * Update an existing MealPlan
   */
  update(mealPlan: MealPlan, input: UpdateMealPlanInput): MealPlan {
    return {
      ...mealPlan,
      ...input,
    };
  },

  /**
   * Validate meal plan data
   */
  validate(mealPlan: MealPlan): string[] {
    const errors: string[] = [];

    if (!mealPlan.recipeId || mealPlan.recipeId.trim().length === 0) {
      errors.push('Recipe ID is required');
    }

    if (!mealPlan.date || !this.isValidDate(mealPlan.date)) {
      errors.push('Valid date is required (YYYY-MM-DD format)');
    }

    if (
      !mealPlan.mealType ||
      !this.isValidMealType(mealPlan.mealType)
    ) {
      errors.push('Valid meal type is required');
    }

    return errors;
  },

  /**
   * Check if date string is valid ISO 8601 date
   */
  isValidDate(dateString: string): boolean {
    const date = new Date(dateString);
    return (
      date instanceof Date &&
      !isNaN(date.getTime()) &&
      !!dateString.match(/^\d{4}-\d{2}-\d{2}$/)
    );
  },

  /**
   * Check if meal type is valid
   */
  isValidMealType(mealType: string): mealType is MealType {
    return Object.values(MealType).includes(mealType as MealType);
  },

  /**
   * Format date for display
   */
  formatDate(dateString: string): string {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  },

  /**
   * Get meal type display name
   */
  getMealTypeDisplayName(mealType: MealType): string {
    return mealType.charAt(0).toUpperCase() + mealType.slice(1);
  },

  /**
   * Group meal plans by date
   */
  groupByDate(mealPlans: MealPlan[]): Record<string, MealPlan[]> {
    return mealPlans.reduce((groups, mealPlan) => {
      const date = mealPlan.date;
      if (!groups[date]) {
        groups[date] = [];
      }
      groups[date].push(mealPlan);
      return groups;
    }, {} as Record<string, MealPlan[]>);
  },

  /**
   * Group meal plans by meal type
   */
  groupByMealType(
    mealPlans: MealPlan[]
  ): Record<MealType, MealPlan[]> {
    return mealPlans.reduce((groups, mealPlan) => {
      const mealType = mealPlan.mealType;
      if (!groups[mealType]) {
        groups[mealType] = [];
      }
      groups[mealType].push(mealPlan);
      return groups;
    }, {} as Record<MealType, MealPlan[]>);
  },

  /**
   * Get meal plans for a specific date range
   */
  getMealPlansInDateRange(
    mealPlans: MealPlan[],
    startDate: string,
    endDate: string
  ): MealPlan[] {
    return mealPlans.filter((mealPlan) => {
      return mealPlan.date >= startDate && mealPlan.date <= endDate;
    });
  },

  /**
   * Check if a meal slot is available for a specific date and meal type
   */
  isMealSlotAvailable(
    mealPlans: MealPlan[],
    date: string,
    mealType: MealType
  ): boolean {
    return !mealPlans.some(
      (mealPlan) =>
        mealPlan.date === date && mealPlan.mealType === mealType
    );
  },
};
