import { MeasurementUnit } from '@/constants/enums';

/**
 * ShoppingListItem interface representing a shopping list item
 */
export interface ShoppingListItem {
  id: string;
  name: string;
  quantity: number | null;
  unit: MeasurementUnit | null;
  checked: boolean;
  recipeId: string | null; // null for manual items
  mealPlanId: string | null; // null for manual items
  createdAt: string; // ISO 8601 datetime
}

/**
 * Input interface for creating a new shopping list item
 */
export interface CreateShoppingListItemInput {
  name: string;
  quantity?: number | null;
  unit?: MeasurementUnit | null;
  checked?: boolean;
  recipeId?: string | null;
  mealPlanId?: string | null;
}

/**
 * Input interface for updating an existing shopping list item
 */
export interface UpdateShoppingListItemInput {
  id: string;
  name?: string;
  quantity?: number | null;
  unit?: MeasurementUnit | null;
  checked?: boolean;
}

/**
 * Database row interface for shopping_list_items table
 */
export interface ShoppingListItemRow {
  id: string;
  name: string;
  quantity: number | null;
  unit: string | null;
  checked: number; // 0 or 1 (SQLite boolean)
  recipeId: string | null;
  mealPlanId: string | null;
  createdAt: string;
}

/**
 * Shopping list item with recipe details (for display purposes)
 */
export interface ShoppingListItemWithRecipe extends ShoppingListItem {
  recipeTitle: string | null;
  recipeImageUri: string | null;
}

/**
 * Aggregated shopping list item (for ingredient aggregation)
 */
export interface AggregatedShoppingListItem extends ShoppingListItem {
  aggregatedQuantity: number;
  aggregatedUnit: MeasurementUnit | null;
  sourceRecipes: string[]; // Array of recipe IDs that contributed to this item
}

/**
 * Utility functions for ShoppingListItem operations
 */
export const ShoppingListItemUtils = {
  /**
   * Convert ShoppingListItem to database row format
   */
  toRow(item: ShoppingListItem): ShoppingListItemRow {
    return {
      id: item.id,
      name: item.name,
      quantity: item.quantity,
      unit: item.unit,
      checked: item.checked ? 1 : 0,
      recipeId: item.recipeId,
      mealPlanId: item.mealPlanId,
      createdAt: item.createdAt,
    };
  },

  /**
   * Convert database row to ShoppingListItem format
   */
  fromRow(row: ShoppingListItemRow): ShoppingListItem {
    return {
      id: row.id,
      name: row.name,
      quantity: row.quantity,
      unit: row.unit as MeasurementUnit | null,
      checked: row.checked === 1,
      recipeId: row.recipeId,
      mealPlanId: row.mealPlanId,
      createdAt: row.createdAt,
    };
  },

  /**
   * Create a new ShoppingListItem with generated ID and timestamp
   */
  create(input: CreateShoppingListItemInput): ShoppingListItem {
    const now = new Date().toISOString();
    return {
      id: '', // Will be generated by service layer
      name: input.name,
      quantity: input.quantity || null,
      unit: input.unit || null,
      checked: input.checked || false,
      recipeId: input.recipeId || null,
      mealPlanId: input.mealPlanId || null,
      createdAt: now,
    };
  },

  /**
   * Update an existing ShoppingListItem
   */
  update(
    item: ShoppingListItem,
    input: UpdateShoppingListItemInput
  ): ShoppingListItem {
    return {
      ...item,
      ...input,
    };
  },

  /**
   * Toggle checked state of an item
   */
  toggleChecked(item: ShoppingListItem): ShoppingListItem {
    return {
      ...item,
      checked: !item.checked,
    };
  },

  /**
   * Check if item is from a recipe (not manual)
   */
  isFromRecipe(item: ShoppingListItem): boolean {
    return item.recipeId !== null;
  },

  /**
   * Check if item is manual (not from recipe)
   */
  isManual(item: ShoppingListItem): boolean {
    return item.recipeId === null;
  },

  /**
   * Validate shopping list item data
   */
  validate(item: ShoppingListItem): string[] {
    const errors: string[] = [];

    if (!item.name || item.name.trim().length === 0) {
      errors.push('Item name is required');
    }

    if (item.name && item.name.length > 100) {
      errors.push('Item name must be 100 characters or less');
    }

    if (
      item.quantity !== null &&
      (item.quantity < 0 || item.quantity > 1000)
    ) {
      errors.push('Quantity must be between 0 and 1000');
    }

    return errors;
  },

  /**
   * Format quantity and unit for display
   */
  formatQuantity(item: ShoppingListItem): string {
    if (item.quantity === null && item.unit === null) {
      return item.name;
    }

    if (item.quantity === null) {
      return `${item.name} (${item.unit})`;
    }

    if (item.unit === null) {
      return `${item.quantity} ${item.name}`;
    }

    return `${item.quantity} ${item.unit} ${item.name}`;
  },

  /**
   * Group items by checked status
   */
  groupByCheckedStatus(items: ShoppingListItem[]): {
    checked: ShoppingListItem[];
    unchecked: ShoppingListItem[];
  } {
    return items.reduce(
      (groups, item) => {
        if (item.checked) {
          groups.checked.push(item);
        } else {
          groups.unchecked.push(item);
        }
        return groups;
      },
      {
        checked: [] as ShoppingListItem[],
        unchecked: [] as ShoppingListItem[],
      }
    );
  },

  /**
   * Group items by recipe source
   */
  groupBySource(items: ShoppingListItem[]): {
    recipeItems: ShoppingListItem[];
    manualItems: ShoppingListItem[];
  } {
    return items.reduce(
      (groups, item) => {
        if (item.recipeId) {
          groups.recipeItems.push(item);
        } else {
          groups.manualItems.push(item);
        }
        return groups;
      },
      {
        recipeItems: [] as ShoppingListItem[],
        manualItems: [] as ShoppingListItem[],
      }
    );
  },

  /**
   * Get items for a specific recipe
   */
  getItemsForRecipe(
    items: ShoppingListItem[],
    recipeId: string
  ): ShoppingListItem[] {
    return items.filter((item) => item.recipeId === recipeId);
  },

  /**
   * Get manual items only
   */
  getManualItems(items: ShoppingListItem[]): ShoppingListItem[] {
    return items.filter((item) => item.recipeId === null);
  },

  /**
   * Get recipe-generated items only
   */
  getRecipeItems(items: ShoppingListItem[]): ShoppingListItem[] {
    return items.filter((item) => item.recipeId !== null);
  },

  /**
   * Check if all items are checked
   */
  areAllChecked(items: ShoppingListItem[]): boolean {
    return items.length > 0 && items.every((item) => item.checked);
  },

  /**
   * Get count of checked items
   */
  getCheckedCount(items: ShoppingListItem[]): number {
    return items.filter((item) => item.checked).length;
  },

  /**
   * Get count of unchecked items
   */
  getUncheckedCount(items: ShoppingListItem[]): number {
    return items.filter((item) => !item.checked).length;
  },
};
