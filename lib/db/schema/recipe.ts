import { DishCategory, MeasurementUnit } from '@/constants/enums';

/**
 * Ingredient interface for recipe ingredients
 */
export interface Ingredient {
  name: string;
  quantity: number | null;
  unit: MeasurementUnit | null;
}

/**
 * Recipe interface representing a complete recipe
 */
export interface Recipe {
  id: string;
  title: string;
  servings: number;
  category: DishCategory;
  ingredients: Ingredient[];
  steps: string[];
  imageUri: string | null;
  prepTime: number | null; // in minutes
  cookTime: number | null; // in minutes
  tags: string[];
  createdAt: string; // ISO 8601 datetime
  updatedAt: string; // ISO 8601 datetime
  deletedAt: string | null; // ISO 8601 datetime for soft delete
}

/**
 * Input interface for creating a new recipe
 */
export interface CreateRecipeInput {
  title: string;
  servings: number;
  category: DishCategory;
  ingredients: Ingredient[];
  steps: string[];
  imageUri?: string | null;
  prepTime?: number | null;
  cookTime?: number | null;
  tags?: string[];
}

/**
 * Input interface for updating an existing recipe
 */
export interface UpdateRecipeInput {
  id: string;
  title?: string;
  servings?: number;
  category?: DishCategory;
  ingredients?: Ingredient[];
  steps?: string[];
  imageUri?: string | null;
  prepTime?: number | null;
  cookTime?: number | null;
  tags?: string[];
}

/**
 * Database row interface for recipes table
 */
export interface RecipeRow {
  id: string;
  title: string;
  servings: number;
  category: string;
  ingredients: string; // JSON string
  steps: string; // JSON string
  imageUri: string | null;
  prepTime: number | null;
  cookTime: number | null;
  tags: string; // JSON string
  createdAt: string;
  updatedAt: string;
  deletedAt: string | null;
}

/**
 * Utility functions for Recipe operations
 */
export const RecipeUtils = {
  /**
   * Convert Recipe to database row format
   */
  toRow(recipe: Recipe): RecipeRow {
    return {
      id: recipe.id,
      title: recipe.title,
      servings: recipe.servings,
      category: recipe.category,
      ingredients: JSON.stringify(recipe.ingredients),
      steps: JSON.stringify(recipe.steps),
      imageUri: recipe.imageUri,
      prepTime: recipe.prepTime,
      cookTime: recipe.cookTime,
      tags: JSON.stringify(recipe.tags),
      createdAt: recipe.createdAt,
      updatedAt: recipe.updatedAt,
      deletedAt: recipe.deletedAt,
    };
  },

  /**
   * Convert database row to Recipe format
   */
  fromRow(row: RecipeRow): Recipe {
    return {
      id: row.id,
      title: row.title,
      servings: row.servings,
      category: row.category as DishCategory,
      ingredients: JSON.parse(row.ingredients),
      steps: JSON.parse(row.steps),
      imageUri: row.imageUri,
      prepTime: row.prepTime,
      cookTime: row.cookTime,
      tags: JSON.parse(row.tags),
      createdAt: row.createdAt,
      updatedAt: row.updatedAt,
      deletedAt: row.deletedAt,
    };
  },

  /**
   * Create a new Recipe with generated ID and timestamps
   */
  create(input: CreateRecipeInput): Recipe {
    const now = new Date().toISOString();
    return {
      id: '', // Will be generated by service layer
      title: input.title,
      servings: input.servings,
      category: input.category,
      ingredients: input.ingredients,
      steps: input.steps,
      imageUri: input.imageUri || null,
      prepTime: input.prepTime || null,
      cookTime: input.cookTime || null,
      tags: input.tags || [],
      createdAt: now,
      updatedAt: now,
      deletedAt: null,
    };
  },

  /**
   * Update an existing Recipe with new timestamps
   */
  update(recipe: Recipe, input: UpdateRecipeInput): Recipe {
    const now = new Date().toISOString();
    return {
      ...recipe,
      ...input,
      updatedAt: now,
    };
  },

  /**
   * Soft delete a Recipe
   */
  softDelete(recipe: Recipe): Recipe {
    const now = new Date().toISOString();
    return {
      ...recipe,
      deletedAt: now,
      updatedAt: now,
    };
  },

  /**
   * Check if a Recipe is deleted
   */
  isDeleted(recipe: Recipe): boolean {
    return recipe.deletedAt !== null;
  },

  /**
   * Get total cooking time (prep + cook)
   */
  getTotalTime(recipe: Recipe): number | null {
    const prep = recipe.prepTime || 0;
    const cook = recipe.cookTime || 0;
    return prep + cook > 0 ? prep + cook : null;
  },

  /**
   * Validate recipe data
   */
  validate(recipe: Recipe): string[] {
    const errors: string[] = [];

    if (!recipe.title || recipe.title.trim().length === 0) {
      errors.push('Title is required');
    }

    if (recipe.title && recipe.title.length > 200) {
      errors.push('Title must be 200 characters or less');
    }

    if (recipe.servings < 1 || recipe.servings > 50) {
      errors.push('Servings must be between 1 and 50');
    }

    if (!recipe.ingredients || recipe.ingredients.length === 0) {
      errors.push('At least one ingredient is required');
    }

    if (!recipe.steps || recipe.steps.length === 0) {
      errors.push('At least one step is required');
    }

    if (
      recipe.prepTime &&
      (recipe.prepTime < 0 || recipe.prepTime > 1440)
    ) {
      errors.push('Prep time must be between 0 and 1440 minutes');
    }

    if (
      recipe.cookTime &&
      (recipe.cookTime < 0 || recipe.cookTime > 1440)
    ) {
      errors.push('Cook time must be between 0 and 1440 minutes');
    }

    return errors;
  },
};
